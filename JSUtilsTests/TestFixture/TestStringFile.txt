Manipulating Dispatch Data for an I/O Channel

All channel-based operations use dispatch_data_t structures to manipulate the data read or written using a channel. A dispatch_data_t structure is an opaque type that manages one or more contiguous memory buffers. The use of an opaque type allows GCD to use discontiguous buffers internally while still presenting the data to your app as if it were more or less contiguous. The actual implementation details of how dispatch data structures work is not important, but understanding how to create them or get data out of them is.

To write data to a dispatch I/O channel, your code must provide a dispatch_data_t structure with the bytes to write. You do this using the dispatch_data_create function, which takes a pointer to a buffer and the size of the buffer and returns a dispatch_data_t structure that encapsulates the data from that buffer. How the data object encapsulates the buffer depends on the destructor you provide when calling the dispatch_data_create function. If you use the default destructor, the data object makes a copy of the buffer and takes care of releasing that buffer at the appropriate time. However, if you do not want the data object to copy the buffer you provide, you must provide a custom destructor block to handle any needed cleanup when the data object itself is released.


Note: If you have multiple data buffers that you want to write to a file as a single contiguous block of data, you can create a single dispatch data object that represents all of those buffers. Using the dispatch_data_create_concat function, you can append additional data buffers to a dispatch_data_t structure. The buffers themselves can all be independent and in different parts of memory but the dispatch data object collects them and represents them as a single entity. (You can even use the dispatch_data_create_map function to generate a contiguous version of your buffers.) Especially for disk-based operations, concatenating multiple buffers lets you write large amounts of data to a file using one call to the dispatch_io_write function, which is much more efficient than calling dispatch_io_write separately for each independent buffer.

To extract bytes from a dispatch data object, you use the dispatch_data_apply function. Because dispatch data objects are opaque, you use this function to iterate over the buffers in the object and process them using a block that you provide. For a dispatch data object with a single contiguous buffer, your block is called once. For a data object with multiple buffers, your block is called as many times as there are buffers. Each time your block is called, it is passed a data buffer and some information about that buffer.

Listing 7-2 shows an example that opens a channel and reads a UTF8 formatted text file, creating NSString objects for the contents of the file. This particular example reads 1024 bytes at a time, which is an arbitrary amount and may not yield the best performance. However, it does demonstrate the basic premise of how to use the dispatch_io_read function in combination with the dispatch_data_apply function to read the bytes and then convert them into a form that your app might want. In this case, the block that processes the bytes uses the dispatch data object?s buffer to initialize a new string object. It then hands the string off to the custom addString:toFile: method, which in this case would store it for later use
